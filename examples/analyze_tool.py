"""
Example: Analyze a tool using Documently
Usage: python analyze_tool.py --tool "Google ADK" --output guide.md
"""

import asyncio
import argparse
import json
import sys
import os
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from main_agent import Documently
from dotenv import load_dotenv

# Load environment variables
load_dotenv()


def print_banner():
    """Print welcome banner"""
    print("\n" + "="*60)
    print("   üìö DOCUMENTLY - AI Documentation Intelligence Agent")
    print("="*60 + "\n")


def print_progress(message: str, step: int = 0, total: int = 0):
    """Print progress message"""
    if total > 0:
        print(f"[{step}/{total}] {message}")
    else:
        print(f"‚è≥ {message}")


async def analyze_tool_cli(
    tool_name: str,
    output_file: str  | None = None,
    use_cache: bool = True,
    parallel: bool = True,
    verbose: bool = False
):
    """
    Analyze a tool and optionally save results
    
    Args:
        tool_name: Name of tool/library to analyze
        output_file: Optional output file path
        use_cache: Whether to use cached results
        parallel: Whether to run agents in parallel
        verbose: Show detailed progress
    """
    print_banner()
    
    api_key = os.getenv('GEMINI_API_KEY')
    if not api_key:
        print("‚ùå Error: GEMINI_API_KEY not found in environment")
        print("Please set it in your .env file")
        return
    
    # Initialize Documently
    print_progress("Initializing Documently agent system...")
    documently = Documently()
    
    # Run analysis
    print_progress(f"Analyzing {tool_name}...")
    print(f"   ‚Ä¢ Cache: {'Enabled' if use_cache else 'Disabled'}")
    print(f"   ‚Ä¢ Mode: {'Parallel' if parallel else 'Sequential'}")
    print()
    
    if verbose:
        print_progress("Step 1: Searching official documentation", 1, 5)
        print_progress("Step 2: Analyzing YouTube tutorials", 2, 5)
        print_progress("Step 3: Mining GitHub insights", 3, 5)
        print_progress("Step 4: Studying real-world usage", 4, 5)
        print_progress("Step 5: Synthesizing results", 5, 5)
        print()
    
    try:
        results = await documently.analyze_tool(
            tool_name=tool_name,
            use_cache=use_cache
        )
        
        print("‚úÖ Analysis complete!\n")
        
        # Display summary
        print("="*60)
        print("COMPREHENSIVE GUIDE")
        print("="*60)
        print(results.get('comprehensive_guide', 'No guide generated'))
        print("\n" + "="*60)
        
        # Display sources used
        sources = results.get('sources_used', [])
        print(f"\nüìä Sources Analyzed: {', '.join(sources)}")
        print(f"üïí Generated: {results.get('generated_at', 'Unknown')}")
        
        # Save to file if requested
        if output_file:
            print(f"\nüíæ Saving results to {output_file}...")
            
            # Determine format from extension
            ext = Path(output_file).suffix.lower()
            
            if ext == '.json':
                with open(output_file, 'w', encoding='utf-8') as f:
                    json.dump(results, f, indent=2, ensure_ascii=False)
            elif ext == '.md':
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(f"# {tool_name} - Developer Guide\n\n")
                    f.write(f"*Generated by Documently on {results.get('generated_at')}*\n\n")
                    f.write("---\n\n")
                    f.write(results.get('comprehensive_guide', ''))
                    f.write("\n\n---\n\n")
                    f.write(f"**Sources**: {', '.join(sources)}\n")
            else:
                # Default to text
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(results.get('comprehensive_guide', ''))
            
            print(f"‚úÖ Saved to {output_file}")
        
        # Show memory stats
        print("\nüìà Session Statistics:")
        print(f"   ‚Ä¢ Total analyses: {len(documently.memory.cache)}")
        print(f"   ‚Ä¢ Tools in cache: {len(documently.memory.cache)}")
        
        print("\n‚ú® Done! Happy coding!\n")
        
    except Exception as e:
        print(f"\n‚ùå Error during analysis: {str(e)}")
        if verbose:
            import traceback
            traceback.print_exc()


async def batch_analyze(tools: list, output_dir: str = "output"):
    """
    Analyze multiple tools in batch
    
    Args:
        tools: List of tool names
        output_dir: Directory to save results
    """
    print_banner()
    print(f"üîÑ Batch Analysis Mode")
    print(f"Tools to analyze: {len(tools)}")
    print(f"Output directory: {output_dir}\n")
    
    # Create output directory
    Path(output_dir).mkdir(exist_ok=True)
    
    documently = Documently()
    
    for i, tool in enumerate(tools, 1):
        print(f"\n[{i}/{len(tools)}] Analyzing {tool}...")
        
        try:
            results = await documently.analyze_tool(
                tool_name=tool,
                use_cache=True
            )
            
            # Save each result
            filename = f"{tool.lower().replace(' ', '_')}_guide.md"
            filepath = Path(output_dir) / filename
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(f"# {tool} - Developer Guide\n\n")
                f.write(results.get('comprehensive_guide', ''))
            
            print(f"   ‚úÖ Saved to {filepath}")
            
        except Exception as e:
            print(f"   ‚ùå Error: {str(e)}")
    
    print(f"\n‚ú® Batch analysis complete! Results in {output_dir}/\n")


def main():
    """CLI entry point"""
    parser = argparse.ArgumentParser(
        description="Documently - Analyze tool documentation",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Analyze single tool
  python analyze_tool.py --tool "Google ADK"
  
  # Save to file
  python analyze_tool.py --tool "Mongoose" --output mongoose_guide.md
  
  # Batch analysis
  python analyze_tool.py --batch "Google ADK,Claude Code,FastAPI" --output-dir guides/
  
  # No cache, sequential mode
  python analyze_tool.py --tool "React" --no-cache --sequential
        """
    )
    
    parser.add_argument(
        '--tool',
        type=str,
        help='Name of tool/library/framework to analyze'
    )
    
    parser.add_argument(
        '--batch',
        type=str,
        help='Comma-separated list of tools for batch analysis'
    )
    
    parser.add_argument(
        '--output', '-o',
        type=str,
        help='Output file path (supports .md, .json, .txt)'
    )
    
    parser.add_argument(
        '--output-dir',
        type=str,
        default='output',
        help='Output directory for batch mode'
    )
    
    parser.add_argument(
        '--no-cache',
        action='store_true',
        help='Disable cache (always fetch fresh data)'
    )
    
    parser.add_argument(
        '--sequential',
        action='store_true',
        help='Run agents sequentially instead of parallel'
    )
    
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show detailed progress'
    )
    
    args = parser.parse_args()
    
    # Validate arguments
    if not args.tool and not args.batch:
        parser.print_help()
        return
    
    # Run appropriate mode
    if args.batch:
        tools = [t.strip() for t in args.batch.split(',')]
        asyncio.run(batch_analyze(tools, args.output_dir))
    else:
        asyncio.run(analyze_tool_cli(
            tool_name=args.tool,
            output_file=args.output,
            use_cache=not args.no_cache,
            parallel=not args.sequential,
            verbose=args.verbose
        ))


if __name__ == "__main__":
    main()